{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"android","text":"","link":"/android/index.html"},{"title":"git","text":"","link":"/git/index.html"},{"title":"http","text":"","link":"/http/http.html"},{"title":"java","text":"","link":"/java/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"AndroidStudio插件","text":"CodeGlance在右边可以预览代码，实现快速定位 Alibaba Java Coding Guidelines阿里出的一个代码编写规范检测的插件。 LayoutFormatter此插件是XML格式化插件，自动排序，能够根据正确的排序顺序进行排序。 android-selector-intellij-plugin插件生成normal，press和按下水波纹颜色下载地址：https://github.com/importre/android-selector-intellij-plugin Android Drawable Importer这个插件能够根据导入的图片，自动生成对应分辨率的图片，比如放入一张图片，他能够生成对应的mdpi,hdpi,xhdpi,xxhdpi,xxxhdpi分辨率的图片，并且当你需要删除一个图片的时候，可以连带的删除其他分辨率对应的图片，不用重复删除。下载地址：https://github.com/winterDroid/android-drawable-importer-intellij-plugin ECTranslation这是一个可以对AndroidStudio中的英文进行翻译的一个插件，以后看源码的时候，就不用再去查字典了，方便多了，也可自定义快捷键。下载地址：https://github.com/Skykai521/ECTranslation","link":"/2019/04/02/AndroidStudio插件/"},{"title":"Android弹出软键盘android:windowSoftInputMode设置","text":"当在Android的layout设计里面如果输入框过多，则在输入弹出软键盘的时候，下面的输入框会有一部分被软件盘挡住，从而不能获取焦点输入。或者是有使用FrameLayout悬浮在底部的Button也会挡住输入框。方法一： 在你的activity中的onCreate中setContentView之前写上这个代码getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); 方法二： 在项目的AndroidManifest.xml文件中界面对应的&lt;activity&gt;里加入android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot;，这样会让屏幕整体上移。如果加上的 android:windowSoftInputMode=&quot;adjustPan&quot;这样键盘就会覆盖屏幕。 方法三： 把顶级的layout替换成ScrollView，或者说在顶级的Layout上面再加一层ScrollView的封装。这样就会把软键盘和输入框一起滚动了，软键盘会一直处于底部。 stateUnspecified软键盘的状态(是否它是隐藏或可见)没有被指定。系统将选择一个合适的状态或依赖于主题的设置。这个是为了软件盘行为默认的设置。 stateUnchanged软键盘被保持无论它上次是什么状态，是否可见或隐藏，当主窗口出现在前面时。 stateHidden当用户选择该Activity时，软键盘被隐藏——也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。 stateAlwaysHidden软键盘总是被隐藏的，当该Activity主窗口获取焦点时。 stateVisible软键盘是可见的，当那个是正常合适的时(当用户导航到Activity主窗口时)。 stateAlwaysVisible当用户选择这个Activity时，软键盘是可见的——也就是当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。 adjustUnspecified它不被指定是否该Activity主窗口调整大小以便留出软键盘的空间，或是否窗口上的内容得到屏幕上当前的焦点是可见的。系统将自动选择这些模式中一种主要依赖于是否窗口的内容有任何布局视图能够滚动他们的内容。如果有这样的一个视图，这个窗口将调整大小，这样的假设可以使滚动窗口的内容在一个较小的区域中可见的。这个是主窗口默认的行为设置。 adjustResize该Activity主窗口总是被调整屏幕的大小以便留出软键盘的空间 adjustPan该Activity主窗口并不调整屏幕的大小以便留出软键盘的空间。相反，当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分。这个通常是不期望比调整大小，因为用户可能关闭软键盘以便获得与被覆盖内容的交互操作。","link":"/2019/05/20/Android弹出软键盘android-windowSoftInputMode设置/"},{"title":"ContentProvider共享手机sd卡中的资源文件","text":"ContentProvider通过uri来标识其它应用要访问的数据，通过ContentResolver的增、删、改、查方法实现对共享数据的操作。还可以通过注册ContentObserver来监听数据是否发生了变化来对应的刷新页面。通过ContentResolver加载手机中的文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556abstract class LocalStorageLoader&lt;T&gt; { protected abstract val context: Context /** * using the content:// scheme, for the content to retrieve. */ protected abstract fun getUri(): Uri /** * A list of which columns to return. Passing null will * return all columns, which is inefficient. */ protected abstract fun getProjection(): Array&lt;String&gt; /** * A filter declaring which rows to return, formatted as an * SQL WHERE clause (excluding the WHERE itself). Passing null will * return all rows for the given URI. */ protected abstract fun getSelection(): String? /** * You may include ?s in selection, which will be * replaced by the values from selectionArgs, in the order that they * appear in the selection. The values will be bound as Strings. */ protected abstract fun getSelectionArgs(): Array&lt;String&gt;? /** * How to order the rows, formatted as an SQL ORDER BY * clause (excluding the ORDER BY itself). Passing null will use the * default sort order, which may be unordered. */ protected abstract fun getSortOrder(): String? protected abstract fun parse(cursor: Cursor): T? fun query(): List&lt;T&gt; { val models = ArrayList&lt;T&gt;() val resolver = context.contentResolver val cursor = resolver.query(getUri(), getProjection(), getSelection(), getSelectionArgs(), getSortOrder()) cursor?.let { while (it.moveToNext()) { val data = parse(cursor) if (null != data) { models.add(data) } } if (!it.isClosed) { it.close() } } return models }} 加载sd卡中的所有jpg,png,gif图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class DefaultImageLoader(override val context: Context) : LocalStorageLoader&lt;FileInfo&gt;() { override fun getUri(): Uri { return MediaStore.Images.Media.EXTERNAL_CONTENT_URI } override fun getProjection(): Array&lt;String&gt; { return arrayOf( MediaStore.Images.Media.DATA, MediaStore.Images.Media.MIME_TYPE, MediaStore.Images.Media.BUCKET_ID, MediaStore.Images.Media.BUCKET_DISPLAY_NAME, MediaStore.Images.Media.DATE_TAKEN, MediaStore.Images.Media.SIZE, MediaStore.Images.Media.DISPLAY_NAME ) } override fun getSelection(): String? { return MediaStore.Images.Media.MIME_TYPE + \"=? or \" + MediaStore.Images.Media.MIME_TYPE + \"=? or \" + MediaStore.Images.Media.MIME_TYPE + \"=?\" } override fun getSelectionArgs(): Array&lt;String&gt;? { return arrayOf(\"image/jpeg\", \"image/png\", \"image/gif\") } override fun getSortOrder(): String? { return MediaStore.Images.Media.DATE_TAKEN + \" desc\" } override fun parse(cursor: Cursor): FileInfo? { val localPath = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)) val mimeType = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.MIME_TYPE)) val parentId = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.BUCKET_ID)) val parentName = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.BUCKET_DISPLAY_NAME)) val dateToken = cursor.getLong(cursor.getColumnIndex(MediaStore.Images.Media.DATE_TAKEN)) val length = cursor.getLong(cursor.getColumnIndex(MediaStore.Images.Media.SIZE)) val displayName = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME)) if (!TextUtils.isEmpty(localPath) &amp;&amp; length &gt; 10240) { val options = BitmapFactory.Options() options.inJustDecodeBounds = true BitmapFactory.decodeFile(localPath, options) return FileInfo(displayName, localPath, length, 0, dateToken, options.outWidth, options.outHeight, mimeType, parentId, parentName) } return null } } 加载sd卡中的所有mp4视频12345678910111213141516171819202122232425262728293031323334353637383940414243444546class DefaultVideoLoader(override val context: Context) : LocalStorageLoader&lt;FileInfo&gt;() { override fun getUri(): Uri { return MediaStore.Video.Media.EXTERNAL_CONTENT_URI } override fun getProjection(): Array&lt;String&gt; { return arrayOf( MediaStore.Video.Media.DATA, MediaStore.Video.Media.MIME_TYPE, MediaStore.Video.Media.BUCKET_ID, MediaStore.Video.Media.BUCKET_DISPLAY_NAME, MediaStore.Video.Media.DURATION, MediaStore.Video.Media.DATE_TAKEN, MediaStore.Video.Media.SIZE, MediaStore.Video.Media.DISPLAY_NAME ) } override fun getSelection(): String? { return MediaStore.Images.Media.MIME_TYPE + \"=?\" } override fun getSelectionArgs(): Array&lt;String&gt;? { return arrayOf(\"video/mp4\") } override fun getSortOrder(): String? { return MediaStore.Video.Media.DATE_TAKEN + \" desc\" } override fun parse(cursor: Cursor): FileInfo? { val localPath = cursor.getString(cursor.getColumnIndex(MediaStore.Video.Media.DATA)) val mimeType = cursor.getString(cursor.getColumnIndex(MediaStore.Video.Media.MIME_TYPE)) val parentId = cursor.getString(cursor.getColumnIndex(MediaStore.Video.Media.BUCKET_ID)) val parentName = cursor.getString(cursor.getColumnIndex(MediaStore.Video.Media.BUCKET_DISPLAY_NAME)) val dateToken = cursor.getLong(cursor.getColumnIndex(MediaStore.Video.Media.DATE_TAKEN)) val duration = cursor.getLong(cursor.getColumnIndex(MediaStore.Video.Media.DURATION)) val length = cursor.getLong(cursor.getColumnIndex(MediaStore.Video.Media.SIZE)) val displayName = cursor.getString(cursor.getColumnIndex(MediaStore.Video.Media.DISPLAY_NAME)) if (!TextUtils.isEmpty(localPath) &amp;&amp; length &gt; 10240) { return FileInfo(displayName, localPath, length, duration, dateToken, 0, 0, mimeType, parentId, parentName) } return null } }","link":"/2019/05/17/ContentProvider共享手机sd卡中的资源文件/"},{"title":"Android MVP架构","text":"Model-View-Presenter是一个分离关注点的软件架构。Presenter作为Model和View之间的桥梁，用于演示业务逻辑。 View对于View层也是视图层，在View层中只负责对数据的展示，提供友好的界面与用户进行交互。在Android开发中通常将Activity或者Fragment作为View层。 Presenter对于Presenter层他是连接View层与Model层的桥梁并对业务逻辑进行处理。在MVP架构中Model与View无法直接进行交互。所以在Presenter层它会从Model层获得所需要的数据，进行一些适当的处理后交由View层进行显示。这样通过Presenter将View与Model进行隔离，使得View和Model之间不存在耦合，同时也将业务逻辑从View中抽离。 Model对于Model层也是数据层。它区别于MVC架构中的Model，在这里不仅仅只是数据模型。在MVP架构中Model它负责对数据的存取操作，例如对数据库的读写，网络的数据的请求等。 注意点： View不与Model直接交互，而是通过与Presenter交互来与Model间接交互。 Presenter与View的交互是通过接口来进行的，更有利于添加单元测试 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。","link":"/2019/05/20/Android-MVP架构/"},{"title":"Charles","text":"https://www.charlesproxy.com/latest-release/download.do Registered Name: https://zhile.io License Key: 48891cf209c6d32bf4","link":"/2019/04/26/Charles/"},{"title":"Android软键盘的显示和隐藏InputMethodManager","text":"如果有需要用到输入的地方，通常会有需要自动弹出或者收起软键盘的需求。想要操作软键盘，需要使用到 InputMethodManager ，它是一个系统服务，可以使用 Context.getSystemService() 获取到它。而很多关键的逻辑代码，都是在 InputMethodManagerService 中实现的。 显示软键盘在 InputMethodManager 中，有两个方法 showSoftInput() 和 showSoftInputFromInputMethod() ，而实际上，只有 showSoftInput() 是有效的。它有两个重载方法，而通常我们会使用它的两个参数的方法。12345678910111213/** * Synonym for {@link #showSoftInput(View, int, ResultReceiver)} without * a result receiver: explicitly request that the current input method's * soft input area be shown to the user, if needed. * * @param view The currently focused view, which would like to receive * soft keyboard input. * @param flags Provides additional operating flags. Currently may be * 0 or have the {@link #SHOW_IMPLICIT} bit set. */public boolean showSoftInput(View view, int flags) { return showSoftInput(view, flags, null);} 这里我们只需要传递两个参数。它首先需要一个 View ，使用软键盘就是为了输入，而输入就需要有接收输入内容的 View ，这里接收输入的 View ，最好是一个 EditText（但这不是必须的）。而第二个参数 flags 就是个标志位，直接传0即可。在 onCreate() 中，如果立即调用 showSoftInput() 是不会生效的。想要在页面一启动的时候就弹出键盘，可以在 Activity 上，设置 android:windowSoftInputMode 属性来完成，或者做一个延迟加载，View.postDelayed() 也是一个解决方案。 隐藏软键盘虽然 showSoftInput() 方法是有效的，但是想要隐藏软键盘，就没有提供对应的 hideSoftInput() 方法，但是却有一个 hideSoftInputFromWindow() 方法，可以用来隐藏软键盘。12345678910111213/** * Synonym for {@link #hideSoftInputFromWindow(IBinder, int, ResultReceiver)} * without a result: request to hide the soft input window from the * context of the window that is currently accepting input. * * @param windowToken The token of the window that is making the request, * as returned by {@link View#getWindowToken() View.getWindowToken()}. * @param flags Provides additional operating flags. Currently may be * 0 or have the {@link #HIDE_IMPLICIT_ONLY} bit set. */public boolean hideSoftInputFromWindow(IBinder windowToken, int flags) { return hideSoftInputFromWindow(windowToken, flags, null);} 它接收两个参数，第一个参数是一个 IBinder ，可以直接传递一个 View.getWindowToken() 的 windowToken 对象就可以了。而第二个参数，就是隐藏软键盘的标志位，如果没有特殊要求的话，直接传递 0 就好了。注意这里虽然原则上需要传递一个之前弹出键盘传递的时候，传递的 View 的 windowToken ，但是实际情况是你只需要传递一个存在于当前布局 ViewTree 中，随意一个 View 的 windowToken 就可以了。 切换键盘的弹出和隐藏在 InputMethodManager 中，还提供了一个 toggleSoftInput() 方法，如同它的名字一样，它可以让软键盘在显示和隐藏之间切换。1234567891011121314151617181920/** * This method toggles the input method window display. * * If the input window is already displayed, it gets hidden. * If not the input window will be displayed. * @param showFlags Provides additional operating flags. May be * 0 or have the {@link #SHOW_IMPLICIT}, * {@link #SHOW_FORCED} bit set. * @param hideFlags Provides additional operating flags. May be * 0 or have the {@link #HIDE_IMPLICIT_ONLY}, * {@link #HIDE_NOT_ALWAYS} bit set. */public void toggleSoftInput(int showFlags, int hideFlags) { if (mCurMethod != null) { try { mCurMethod.toggleSoftInput(showFlags, hideFlags); } catch (RemoteException e) { } }} 该方法，接收两个 flags ，分别是控制 show 和 hide 时候的标识，它们的含义和前面介绍的 showSoftInput() 和 hideSoftInputFromWindow() 一致，所以没有特殊要求，直接传递 0 就好了。toggleSoftInput() 方法不要求传递一个 View 或者 windowToken，所以它并没有 showSoftInput() 中的一些限制，但是依然还有需要在布局绘制完成之后调用才会有效果。虽然这个方法，限制很少，但是我们基本上不会使用它。主要原因在于，它是一个开关的方法，会根据当前的状态做相反的操作。这就导致很多时候，我们在代码中，无法直接根据 InputMethodManager 提供的方法判断当前软键盘的显示状态，这样也就无法确定调用它的时候的效果了。","link":"/2019/05/20/Android软键盘的显示和隐藏InputMethodManager/"},{"title":"git常用配置","text":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。保存账号和密码1git config --global credential.helper store 忽略ssl验证 git config --global http.sslVerify \"false\"","link":"/2019/04/01/git常用配置/"},{"title":"我的开发仓库","text":"仓库https://rdc.aliyun.com/123456789101112131415161718192021allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/public' } maven { credentials { username 'XCkvR2' password 'gtLD60Rgku' } url 'https://repo.rdc.aliyun.com/repository/69789-release-2uR2Yk/' } maven { credentials { username 'XCkvR2' password 'gtLD60Rgku' } url 'https://repo.rdc.aliyun.com/repository/69789-snapshot-8Y8wCL/' } }} mvp1implementation \"org.kakrot.mvp:mvp:1.0\"","link":"/2019/05/20/我的开发仓库/"},{"title":"jdk的安装与环境配置","text":"https://www.oracle.com/technetwork/java/javase/downloads/index.html Mac1.打开终端Terminal2.vim .bash_profile3.输入如下配置,然后wq保存关闭该窗口123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH 4.使用”source .bash_profile”使配置生效 Ubuntu1.打开终端Terminal2.sudo vim /etc/profile3.输入如下配置,然后wq保存关闭该窗口1234export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_191export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 4.使用”source /etc/profile”使配置生效 Window1.新建系统变量：JAVA_HOME=C:\\Program Files\\Java\\jdk1.8.0_1912.在系统变量Path后面追加;%JAVA_HOME%\\bin3.新建系统变量：CLASSPATH=.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar","link":"/2019/04/01/jdk的安装与环境配置/"},{"title":"自定义LiveDataBus事件分发","text":"对于Android系统来说，消息传递是最基本的组件，每一个App内的不同页面，不同组件都在进行消息传递。消息传递既可以用于Android四大组件之间的通信，也可用于异步线程和主线程之间的通信。对于Android开发者来说，经常使用的消息传递方式有很多种，从最早使用的Handler、BroadcastReceiver、接口回调，到近几年流行的通信总线类框架EventBus、RxBus。Android消息传递框架，总在不断的演进之中。 123456789101112131415161718192021222324class LiveDataBus private constructor() { private val mCaches = HashMap&lt;String, MutableLiveData&lt;Any&gt;&gt;() companion object { val with by lazy(LazyThreadSafetyMode.SYNCHRONIZED) { LiveDataBus() } } fun &lt;T&gt; get(owner: LifecycleOwner, target: String, onChange: (T?) -&gt; Unit) { if (!mCaches.containsKey(target)) { mCaches[target] = MutableLiveData() } mCaches[target]?.let { liveData -&gt; (liveData as MutableLiveData&lt;T&gt;).observe(owner, Observer { onChange(it) }) } } fun post(target: String, value: Any) { if (mCaches.containsKey(target)) { mCaches[target]?.postValue(value) } }}","link":"/2019/05/17/自定义LiveDataBus事件分发/"},{"title":"阿里巴巴Android开发手册","text":"点击下载","link":"/2019/05/20/阿里巴巴Android开发手册/"},{"title":"自己动手封装RecyclerView.Adapter","text":"RecyclerView封装了ViewHolder的回收复用，也就是说RecyclerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。直接省去了ListView中convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。 提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。设置布局管理器以控制Item的布局方式，横向、竖向以及瀑布流方式可设置Item的间隔样式（可绘制），通过继承RecyclerView的ItemDecoration这个类，然后针对自己的业务需求去书写代码。可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecyclerView有其自己默认的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * 自定义封装RecyclerView.Adapter */abstract class RecyclerViewAdapter&lt;M&gt; : RecyclerView.Adapter&lt;RecyclerViewHolder&gt;() { companion object { /** * 加载中 */ private const val LOADING = 0 /** * 加载失败 */ private const val LOAD_FAILURE = 1 /** * 全部加载完成 */ private const val LOAD_COMPLETE = 2 } abstract val models: List&lt;M&gt; private var isEnableLoadMore: Boolean = false private var mOnLoadMoreListener: OnLoadMoreListener? = null private var mOnItemClickListener: OnItemClickListener? = null private var mOnItemLongClickListener: OnItemLongClickListener? = null private var mLoadStatus: Int = LOADING fun setLoadMoreComplete(hasMore: Boolean) { this.isEnableLoadMore = hasMore this.mLoadStatus = if (hasMore) LOADING else LOAD_COMPLETE notifyDataSetChanged() } fun setLoadMoreFailure() { this.mLoadStatus = LOAD_FAILURE notifyItemChanged(itemCount - 1) } fun setOnLoadMoreListener(listener: OnLoadMoreListener) { this.mOnLoadMoreListener = listener } fun setOnItemClickListener(listener: OnItemClickListener) { this.mOnItemClickListener = listener } fun setOnItemLongClickListener(listener: OnItemLongClickListener) { this.mOnItemLongClickListener = listener } override fun getItemViewType(position: Int): Int { if (this.isEnableLoadMore &amp;&amp; position == this.models.size) { return R.layout.rv_load_more } return getItemViewLayout(position) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerViewHolder { val inflater = LayoutInflater.from(parent.context) val view = inflater.inflate(viewType, parent, false) val holder = RecyclerViewHolder(view) holder.itemView.setOnClickListener { val position = holder.adapterPosition if (position != RecyclerView.NO_POSITION) { mOnItemClickListener?.onItemClick(it, position) } } holder.itemView.setOnLongClickListener { val position = holder.adapterPosition if (position != RecyclerView.NO_POSITION) { mOnItemLongClickListener?.onItemLongClick(it, position) } false } return holder } override fun getItemCount(): Int { return if (this.isEnableLoadMore) this.models.size + 1 else this.models.size } override fun onBindViewHolder(holder: RecyclerViewHolder, position: Int) { if (getItemViewType(position) == R.layout.rv_load_more) { bindLoadMoreViewHolder(holder) } else { convert(holder, this.models[position]) } } private fun bindLoadMoreViewHolder(holder: RecyclerViewHolder) { holder.setText(R.id.load_status, when (this.mLoadStatus) { LOAD_FAILURE -&gt; R.string.load_failure LOAD_COMPLETE -&gt; R.string.load_complete else -&gt; R.string.loading }) .setVisibility(R.id.load_progress, if (this.mLoadStatus == LOADING) View.VISIBLE else View.GONE) } override fun onViewAttachedToWindow(holder: RecyclerViewHolder) { if (this.isEnableLoadMore &amp;&amp; holder.adapterPosition == itemCount - 1) { this.mOnLoadMoreListener?.onLoadMore() } } /** * 返回的是当前item的布局id */ protected abstract fun getItemViewLayout(position: Int): Int protected abstract fun convert(holder: RecyclerViewHolder, model: M) interface OnLoadMoreListener { fun onLoadMore() } interface OnItemClickListener { fun onItemClick(view: View, position: Int) } interface OnItemLongClickListener { fun onItemLongClick(view: View, position: Int): Boolean }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455open class RecyclerViewHolder(view: View) : RecyclerView.ViewHolder(view) { private val cache = SparseArray&lt;View&gt;() val context: Context by lazy { itemView.context } @Suppress(\"UNCHECKED_CAST\") fun &lt;V : View&gt; getView(@IdRes id: Int): V { var view = cache.get(id) if (null == view) { view = itemView.findViewById(id) cache.put(id, view) } return view as V } fun setText(@IdRes id: Int, @StringRes text: Int): RecyclerViewHolder { getView&lt;TextView&gt;(id).setText(text) return this } fun setText(@IdRes id: Int, text: CharSequence): RecyclerViewHolder { getView&lt;TextView&gt;(id).text = text return this } fun setImageResource(@IdRes id: Int, @DrawableRes resId: Int): RecyclerViewHolder { getView&lt;ImageView&gt;(id).setImageResource(resId) return this } fun setImageBitmap(@IdRes id: Int, bitmap: Bitmap): RecyclerViewHolder { getView&lt;ImageView&gt;(id).setImageBitmap(bitmap) return this } fun setBackgroundColor(@IdRes id: Int, @ColorInt color: Int): RecyclerViewHolder { getView&lt;View&gt;(id).setBackgroundColor(color) return this } fun setBackgroundResource(@IdRes id: Int, @DrawableRes resId: Int): RecyclerViewHolder { getView&lt;View&gt;(id).setBackgroundResource(resId) return this } fun setVisibility(@IdRes id: Int, visibility: Int): RecyclerViewHolder { getView&lt;View&gt;(id).visibility = visibility return this } fun setEnable(@IdRes id: Int, enable: Boolean): RecyclerViewHolder { getView&lt;View&gt;(id).isEnabled = enable return this }}","link":"/2019/05/18/自己动手封装RecyclerView-Adapter/"},{"title":"阿里巴巴Java开发手册","text":"点击下载","link":"/2019/05/20/阿里巴巴Java开发手册/"}],"tags":[{"name":"android","slug":"android","link":"/tags/android/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"android","slug":"android","link":"/categories/android/"},{"name":"android软键盘","slug":"android软键盘","link":"/categories/android软键盘/"},{"name":"mvp","slug":"mvp","link":"/categories/mvp/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"repository","slug":"repository","link":"/categories/repository/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"阿里巴巴Android开发手册","slug":"阿里巴巴Android开发手册","link":"/categories/阿里巴巴Android开发手册/"},{"name":"阿里巴巴Java开发手册","slug":"阿里巴巴Java开发手册","link":"/categories/阿里巴巴Java开发手册/"}]}